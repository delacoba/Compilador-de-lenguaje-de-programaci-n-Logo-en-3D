import ply.lex as lex

# LISTA DE TOKENS QUE RECONOCE NUESTRO ANALIZADOR
tokens = ['IDENTIFICADOR', 'VARIABLE', 'LITERAL_ENTERO', 'LITERAL_DECIMAL',
          'MAS', 'MENOS', 'MULTIPLICAR', 'DIVIDIR', 
          'CORCHETE_IZDA', 'CORCHETE_DCHA', 'PARENTESIS_IZDA', 'PARENTESIS_DCHA', 
          'IGUAL', 'COMA', 'PERSPECTIVA', 'COLOR'
        ]

#Diccionario de palabras reservadas
reservadas = [
    # DEFINIMOS LAS PALABRAS RESERVADAS CORRESPONDIENTES A UNA PALABRA RESERVADA
    # PALABRA RESERVADA PARA INDICAR EL COMIENZO DE PROGRAMA
    'PROGRAM',

    # PALABRA RESERVADA PARA INDICAR EL COMIENZO Y FIN DE PROCEDIMIENTO 
    'PARA',
    'FIN',  

    # PALABRA RESERVADA PARA EJECUTAR UN PROCEDIMIENTO 
    'CALL',

    # PALABRAS RESERVADAS QUE NOS PERMITE DESPLAZAR LA TORTUGA
    'AVANZA',
    'RETROCEDE',

    # PALABRAS RESERVADAS QUE NOS PERMITE GIRAR LA TORTUGA POR LOS DIFERENTES EJES,    
    'GIRADERECHA',
    'GIRAZQUIERDA',    
    'CABECEAARRIBA',
    'CABECEAABAJO', 
    'DERIVADERECHA',
    'DERIVAIZQUIERDA',

    # PALABRAS RESERVADAS PARA ESTABLECER SI SE DIBUJA O NO MIENTRAS SE DESPLAZA LA TORTUGA
    'SUBELAPIZ',
    'BAJALAPIZ',

    # PALABRA RESERVADA QUE PEWRMITE BORRAR AL DESPLAZARSE LA TORTUGA
    'GOMA',
    
    # PALABRA RESERVADA QUE POSICIONA LA TORTUGA EN EL PUNTO INICIAL
    'CENTRO',

    # PALABRAS RESERVADAS PARA ESTABLECER LOS COLORES DEL FONO Y CON LOS QUE DIBUJAREMOS
    'COLORFONDO',
    'COLORLAPIZ',

    # PALABRA RESERVADA QUE PERMITE REALIZAR BUCLES
    'REPITE'
    ]
   
tokens += reservadas

# DICCIONARIO DE ABREVIATURAS DEL LOGO3D. AL LEERLAS SE REEMPLAZARÁ POR EL EQUIVALENTE, TOKEN O PALABRA RESERVADA
equivalencias = {
    'AV':'AVANZA',
    'RE':'RETROCEDE',

    'GD':'GIRADERECHA',
    'GI':'GIRAZQUIERDA', 
    'CA':'CABECEAARRIBA',
    'CB':'CABECEAABAJO', 
    'DD':'DERIVADERECHA',
    'DI':'DERIVAIZQUIERDA',

    'SL':'SUBELAPIZ',
    'BL':'BAJALAPIZ',

    'CF':'COLORFONDO',
    'CL':'COLORLAPIZ',

    'VISTA_ARRIBA':'PERSPECTIVA',
    'VISTA_ABAJO':'PERSPECTIVA',
    'VISTA_DERECHA':'PERSPECTIVA',
    'VISTA_IZQUIERDA':'PERSPECTIVA',
    'VISTA_ANTERIOR':'PERSPECTIVA',
    'VISTA_POSTERIOR':'PERSPECTIVA',
    'VISTA_GABINETE':'PERSPECTIVA',
    'VISTA_PERSPECTIVA':'PERSPECTIVA',
    }

#DICCIONARIO PARA ESTABLECER QUE COLORES SE HAN UTILIZADO EN NUESTRO PROGRAMA Y NO GENERAR LAS VARIABLES DE COLORES BASICOS INNECESARIAS
colores={
    'NEGRO':False,
    'AZUL':False,
    'VERDE':False,   
    'AZULCLARO':False,
    'ROJO':False,
    'ROSA':False,   
    'AMARILLO':False,
    'BLANCO':False,
    'CAFE':False,
    'CAFECLARO':False,
    'VERDEMEDIO':False,   
    'VERDEAZUL':False,
    'SALMON':False,
    'LILA':False,   
    'NARANJA':False,
    'GRIS':False,
}

# DEFINIMOS LAS REGLAS DE EXPRESIÓN DE LOS TOKENS MAS SENCILLOS
t_MAS = r'\+'
t_MENOS = r'\-'
t_MULTIPLICAR = r'\*'
t_DIVIDIR = r'/'

t_CORCHETE_IZDA = r'\['
t_CORCHETE_DCHA = r'\]'
t_PARENTESIS_IZDA = r'\('
t_PARENTESIS_DCHA = r'\)'

t_IGUAL = r'\='
t_COMA = r'\,'


# DEFINIMOS LA REGLA PARA IGNORAR LOS ESPACIOS y LOS TABULADORES
t_ignore  = ' \t'


# DEFINIMOS LAS REGLAS DE LOS DEMAS TOKENS. AL SER MAS COMPLEJAS SE UTILIZAN FUNCIONES
def t_LITERAL_DECIMAL(t):    
    r'\d+\.\d+'
    t.value=float(t.value)
    return t

def t_LITERAL_ENTERO(t):    
    r'\d+'
    t.value=int(t.value)
    return t

def t_VARIABLE(t):
    r':[a-zA-Z][a-zA-Z0-9_]*'
    t.value = t.value.upper()[1:]
    return t

# EN EL CASO DE DETECTAR UN IDENTIFICADOR, DEBEMOS COMPROBAR SI CORRESPONDE A UNA PALABRA RESERVADA (COMANDO), UN COLOR, O EQUIVALENCIA
def t_IDENTIFICADOR(t):
    r'[a-zA-Z][a-zA-Z0-9_]*'
    
    # PARA QUE EL LENGUAJE NO SEA SENSIBLE A MINUSCULAS/MAYUSCULAS, SE PASA TODO A MAYUSCULAS
    t.value = t.value.upper()
    
    if t.value in colores:
        t.type = 'COLOR'
        colores[t.value] = True # NOS PERMITE SABER QUE ESTE COLOR SE HA UTILIZADO EN NUESTRO PROGRAMA, PARA PODER OPTIMIZAR ELIMINANDO LOS NO USADOS.

    elif t.value in equivalencias:
        t.type = equivalencias[t.value]

    elif t.value in reservadas:        
        t.type = t.value 

    return t

# DEFINIMOS LA REGLA PARA DETECTAR LOS SALTOS DE LINEA
def t_newline(t):
    r'\n+'
    t.lexer.lineno += len(t.value)
    
# DEFINIMOS LA REGLA PARA IGNORAR COMENTARIOS 
def t_COMMENT(t):
    r'\#.*'

# DEFINIMOS UNA FUNCIÓN PARA MANEJAR LAS REGLAS QUE NO TUVIERAMOS CONTEMPLADAS
def t_error(t):   
    # UTILIZAMOS NUESTRO PROPIO ATRIBUTO QUE CONTIENE LOS ERRORES DETECTADOS    
    lex.lexer.erroresLexicosDetectados.append(t)
    lex.lexer.numErroresLexicos += 1    
    t.lexer.skip(1)

# INICIALIZAMOS NUESTRO ANALIZADOR LEXICO
analizadorLexico  = lex.lex()

# UTILIZAMOS NUESTRAS PROPIOS ATRIBUTOS PARA CONTROLAR LOS ERRORES DETECTADOS POR EL ANALIZADOR LEXICO
lex.lexer.numErroresLexicos = 0
lex.lexer.erroresLexicosDetectados = [ ]